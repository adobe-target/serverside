const url = require("url");
const http = require("request");
const uuid = require("uuid/v4");
const createTargetCookies = require("./utils/target-cookies");

const HOST = "tt.omtrdc.net";
const PATH = "/rest/v1/mbox/";
const PROTOCOL = "http://";
const SECURE_PROTOCOL = "https://";
const TIMEOUT = 3000;
const SESSION_ID_COOKIE = "session";
const DEVICE_ID_COOKIE = "PC";
const SESSION_ID_EXPIRES = 1860;
const DEVICE_ID_EXPIRES = 63244800;
const DEVICE_ID_KEY = "tntId";
const REFERER_HEADER = "referer";
const HOST_KEY = "host";
const PAGE_URL_KEY = "pageURL";
const REFERER_URL_KEY = "referrerURL";
const REQUEST_LOCATION_KEY = "requestLocation";
const MBOX_MISSING = "Mbox parameter is mandatory";
const LOG_PREFIX = "Target Node Client:";

function getSessionId(targetCookies) {
  const cookies = targetCookies.readCookies();
  const sessionIdCookie = cookies[SESSION_ID_COOKIE];
  const result = sessionIdCookie && sessionIdCookie.value;

  return result || String(uuid()).replace(/-/g, "");
}

function getDeviceId(targetCookies) {
  const cookies = targetCookies.readCookies();
  const deviceIdCookie = cookies[DEVICE_ID_COOKIE];

  return deviceIdCookie && deviceIdCookie.value;
}

function getHost(request) {
  return request.hostname;
}

function getPageUrl(request) {
  return url.format({
    protocol: request.protocol,
    hostname: request.hostname,
    pathname: request.originalUrl
  });
}

function getRefererUrl(request) {
  return request.headers[REFERER_HEADER];
}

function createRequestLocation(request) {
  const result = {};
  const host = getHost(request);
  const pageUrl = getPageUrl(request);
  const refererUrl = getRefererUrl(request);

  if (host) {
    result[HOST_KEY] = host;
  }

  if (pageUrl) {
    result[PAGE_URL_KEY] = pageUrl;
  }

  if (refererUrl) {
    result[REFERER_URL_KEY] = refererUrl;
  }

  return result;
}

function updateRequestLocation(base, provided) {
  Object.keys(provided)
    .filter(key => key !== REQUEST_LOCATION_KEY)
    .forEach(key => base[key] = provided[key]);

  Object.keys(provided[REQUEST_LOCATION_KEY] || {})
    .forEach(key => {
      base[REQUEST_LOCATION_KEY][key] = provided[REQUEST_LOCATION_KEY][key];
    });
}

module.exports = function createTargetClient(options = {}) {
  const client = options.client;

  if (!client) {
    throw new Error("Client settings is missing");
  }

  const debug = options.debug === undefined ? false : options.debug === true;
  const secure = options.secure === undefined ? true : options.secure;
  const protocol = secure ? SECURE_PROTOCOL : PROTOCOL;
  const timeout = options.timeout || TIMEOUT;
  const host = options.host || `${client}.${HOST}`;

  function log(...params) {
    if (debug) {
      console.log.apply(console, [].concat.apply([LOG_PREFIX], params));
    }
  }

  function createSimpleTargetRequest(data) {
    const sessionId = uuid();
    const json = {};
    const queryString = {client};
    json[REQUEST_LOCATION_KEY] = {};

    updateRequestLocation(json, data);

    return {
      uri: `${protocol}${host}${PATH}${sessionId}`,
      timeout: timeout,
      qs: queryString,
      json: json
    };
  }

  function createComplexTargetRequest(data, sessionId, deviceId, request) {
    const json = {};
    const queryString = {client};
    json[REQUEST_LOCATION_KEY] = createRequestLocation(request);

    updateRequestLocation(json, data);

    if (deviceId) {
      json[DEVICE_ID_KEY] = deviceId;
    }

    return {
      uri: `${protocol}${host}${PATH}${sessionId}`,
      timeout: timeout,
      qs: queryString,
      json: json
    };
  }

  function addTracking(targetCookies, sessionId, deviceId) {
    const nowInSeconds = Date.now() / 1000;
    const cookies = targetCookies.readCookies();

    if (sessionId) {
      log("user tracking, sessionId:", sessionId);
      cookies[SESSION_ID_COOKIE] = {
        name: SESSION_ID_COOKIE,
        value: sessionId,
        expires: Math.ceil(SESSION_ID_EXPIRES + nowInSeconds)
      };
    }

    if (deviceId) {
      log("user tracking, deviceId:", deviceId);
      cookies[DEVICE_ID_COOKIE] = {
        name: DEVICE_ID_COOKIE,
        value: deviceId,
        expires: Math.ceil(DEVICE_ID_EXPIRES + nowInSeconds)
      };
    }

    targetCookies.saveCookies(cookies);
  }

  function executeHttpPost(targetRequest) {
    return new Promise((resolve, reject) => {
      http.post(targetRequest, function (error, message, json) {
        if (error) {
          log("error", error);
          reject(error);
          return;
        }

        if (message.statusCode !== 200) {
          log("status code <> 200", message.statusCode, json);
          reject(json);
          return;
        }

        log("response", json);
        resolve(json);
      });
    });
  }

  function executeComplexRequest(data, request, response) {
    const targetCookies = createTargetCookies(request, response);
    const sessionId = getSessionId(targetCookies);
    const deviceId = getDeviceId(targetCookies);
    const targetRequest = createComplexTargetRequest(data, sessionId, deviceId, request);

    log("request", targetRequest);

    return executeHttpPost(targetRequest)
      .then(json => {
        addTracking(targetCookies, sessionId, json[DEVICE_ID_KEY] || deviceId);

        return {content: json.content};
      });
  }

  function executeSimpleRequest(data) {
    const sessionId = uuid();
    const deviceId = null;
    const targetRequest = createSimpleTargetRequest(data, sessionId, deviceId);

    log("request", targetRequest);

    return executeHttpPost(targetRequest)
      .then(json => {
        return {content: json.content};
      });
  }

  function executeRequest(data, request, response) {
    if (!data.mbox) {
      log("validation failed", MBOX_MISSING);
      return Promise.reject(MBOX_MISSING);
    }

    if (request && response) {
      log("request and response are present, use user tracking");
      return executeComplexRequest(data, request, response);
    }

    log("request and response are missing, no user tracking");
    return executeSimpleRequest(data);
  }

  return {
    execute: (data = {}, request = null, response = null) => executeRequest(data, request, response)
  };
};
